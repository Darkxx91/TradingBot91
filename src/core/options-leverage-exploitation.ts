// OPTIONS LEVERAGE EXPLOITATION SYSTEM - REVOLUTIONARY ASYMMETRIC RETURNS ENGINE
// Exploit options pricing inefficiencies for 100-1000x effective leverage with limited downside

import { EventEmitter } from 'events';
import { v4 as uuidv4 } from 'uuid';
import ExchangeManager from '../exchanges/exchange-manager';
import { TradeSignal } from '../types/core';

/**
 * Option type
 */
export enum OptionType {
  CALL = 'call',
  PUT = 'put'
}

/**
 * Option style
 */
export enum OptionStyle {
  EUROPEAN = 'european',
  AMERICAN = 'american'
}

/**
 * Exchange
 */
export enum Exchange {
  DERIBIT = 'deribit',
  OKX = 'okx',
  BYBIT = 'bybit',
  BINANCE = 'binance',
  BITCOM = 'bitcom',
  DELTA = 'delta',
  ZETA = 'zeta'
}

/**
 * Option contract
 */
export interface OptionContract {
  exchange: Exchange;
  symbol: string;
  baseAsset: string;
  quoteAsset: string;
  optionType: OptionType;
  optionStyle: OptionStyle;
  strike: number;
  expiryDate: Date;
  lastPrice: number;
  markPrice: number;
  underlyingPrice: number;
  bid: number;
  ask: number;
  delta: number;
  gamma: number;
  vega: number;
  theta: number;
  impliedVolatility: number;
  openInterest: number;
  volume24h: number;
  lastUpdated: Date;
}
/*
*
 * Options leverage opportunity
 */
export interface OptionsLeverageOpportunity {
  id: string;
  baseAsset: string;
  quoteAsset: string;
  exchange: Exchange;
  contract: OptionContract;
  underlyingPrice: number;
  effectiveLeverage: number;
  maxReturn: number;
  maxLoss: number;
  breakEvenPrice: number;
  probabilityOfProfit: number;
  riskRewardRatio: number;
  daysToExpiry: number;
  impliedVolatility: number;
  historicalVolatility: number;
  volatilitySkew: number;
  ivPercentile: number;
  confidence: number;
  strategy: OptionsStrategy;
  detectedAt: Date;
  status: 'active' | 'executed' | 'completed' | 'expired' | 'failed';
  notes: string[];
}

/**
 * Options strategy
 */
export enum OptionsStrategy {
  LONG_CALL = 'long_call',
  LONG_PUT = 'long_put',
  CALL_SPREAD = 'call_spread',
  PUT_SPREAD = 'put_spread',
  IRON_CONDOR = 'iron_condor',
  STRADDLE = 'straddle',
  STRANGLE = 'strangle',
  BUTTERFLY = 'butterfly',
  CALENDAR_SPREAD = 'calendar_spread'
}

/**
 * Options trade
 */
export interface OptionsTrade {
  id: string;
  opportunityId: string;
  baseAsset: string;
  quoteAsset: string;
  exchange: Exchange;
  strategy: OptionsStrategy;
  legs: OptionsLeg[];
  premium: number;
  maxProfit: number;
  maxLoss: number;
  breakEvenPrice: number;
  effectiveLeverage: number;
  initialUnderlyingPrice: number;
  currentUnderlyingPrice: number;
  currentValue: number;
  pnl: number;
  pnlPercentage: number;
  status: 'pending' | 'active' | 'completed' | 'expired' | 'failed';
  entryTime: Date | null;
  exitTime: Date | null;
  notes: string[];
}/**

 * Options leg
 */
export interface OptionsLeg {
  contract: OptionContract;
  action: 'buy' | 'sell';
  quantity: number;
  price: number;
  executed: boolean;
  executionTime: Date | null;
  currentValue: number;
}

/**
 * Volatility surface
 */
export interface VolatilitySurface {
  baseAsset: string;
  exchange: Exchange;
  timestamp: Date;
  expiryDates: Date[];
  strikes: number[];
  impliedVolatilities: Map<string, number>; // key: expiry_strike
  skew: Map<string, number>; // key: expiry
  term: Map<number, number>; // key: days to expiry
}

/**
 * Options leverage configuration
 */
export interface OptionsLeverageConfig {
  minEffectiveLeverage: number;
  minProbabilityOfProfit: number;
  minRiskRewardRatio: number;
  minConfidence: number;
  maxPositionSizeUsd: number;
  maxActiveTrades: number;
  scanIntervalMs: number;
  monitoredExchanges: Exchange[];
  preferredStrategies: OptionsStrategy[];
  volatilityPercentileThreshold: number;
  daysToExpiryMin: number;
  daysToExpiryMax: number;
}

/**
 * Options Leverage Exploitation System
 * 
 * REVOLUTIONARY INSIGHT: Options provide asymmetric return profiles with limited
 * downside and unlimited upside potential. By carefully selecting options with
 * optimal strike prices, expiration dates, and implied volatility characteristics,
 * we can achieve 100-1000x effective leverage while strictly limiting maximum loss.
 */
export class OptionsLeverageExploitation extends EventEmitter {
  private exchangeManager: ExchangeManager;
  private config: OptionsLeverageConfig;
  private optionContracts: Map<string, OptionContract> = new Map();
  private opportunities: Map<string, OptionsLeverageOpportunity> = new Map();
  private activeTrades: Map<string, OptionsTrade> = new Map();
  private completedTrades: OptionsTrade[] = [];
  private volatilitySurfaces: Map<string, VolatilitySurface> = new Map();
  private monitoredAssets: string[] = [];
  private isRunning: boolean = false;
  private scanInterval: NodeJS.Timeout | null = null;
  private accountBalance: number = 1000;
  private accountId: string = 'default';  /**
   *
 Constructor
   * @param exchangeManager Exchange manager
   * @param config Configuration
   */
  constructor(
    exchangeManager: ExchangeManager,
    config?: Partial<OptionsLeverageConfig>
  ) {
    super();
    this.exchangeManager = exchangeManager;
    
    // Default configuration
    this.config = {
      minEffectiveLeverage: 20, // Minimum 20x effective leverage
      minProbabilityOfProfit: 0.3, // 30% minimum probability of profit
      minRiskRewardRatio: 3, // 3:1 minimum risk-reward ratio
      minConfidence: 0.7, // 70% minimum confidence
      maxPositionSizeUsd: 5000, // $5,000 maximum position size
      maxActiveTrades: 10,
      scanIntervalMs: 60 * 1000, // 1 minute
      monitoredExchanges: [
        Exchange.DERIBIT,
        Exchange.OKX,
        Exchange.BYBIT,
        Exchange.BINANCE
      ],
      preferredStrategies: [
        OptionsStrategy.LONG_CALL,
        OptionsStrategy.LONG_PUT,
        OptionsStrategy.CALL_SPREAD,
        OptionsStrategy.PUT_SPREAD
      ],
      volatilityPercentileThreshold: 20, // Look for options with IV in bottom 20th percentile
      daysToExpiryMin: 7, // Minimum 7 days to expiry
      daysToExpiryMax: 45 // Maximum 45 days to expiry
    };
    
    // Override with provided config
    if (config) {
      this.config = { ...this.config, ...config };
    }
  }
  
  /**
   * Start the options leverage exploitation system
   * @param assets Assets to monitor
   * @param accountId Account ID
   * @param accountBalance Account balance
   */
  async start(
    assets: string[] = ['BTC', 'ETH', 'SOL'],
    accountId: string = 'default',
    accountBalance: number = 1000
  ): Promise<void> {
    if (this.isRunning) {
      console.log('💰 Options leverage exploitation system already running');
      return;
    }
    
    console.log('🚀 STARTING OPTIONS LEVERAGE EXPLOITATION SYSTEM...');
    
    // Set account details
    this.accountId = accountId;
    this.accountBalance = accountBalance;
    
    // Set monitored assets
    this.monitoredAssets = assets;
    
    // Initialize option contracts
    await this.initializeOptionContracts();
    
    // Start monitoring options markets
    this.startOptionsMonitoring();
    
    // Start opportunity scanning
    this.startOpportunityScan();
    
    this.isRunning = true;
    console.log(`💰 OPTIONS LEVERAGE EXPLOITATION SYSTEM ACTIVE! Monitoring ${this.monitoredAssets.length} assets across ${this.config.monitoredExchanges.length} exchanges`);
  } 
 /**
   * Initialize option contracts
   */
  private async initializeOptionContracts(): Promise<void> {
    console.log('🏗️ INITIALIZING OPTION CONTRACTS...');
    
    // In a real implementation, this would fetch all available option contracts
    // For now, we'll create simulated option contracts
    
    // Create contracts for each monitored asset
    for (const asset of this.monitoredAssets) {
      // Create option contracts for different exchanges, strikes, and expiries
      this.createSimulatedOptionContracts(asset);
    }
    
    console.log(`✅ INITIALIZED ${this.optionContracts.size} OPTION CONTRACTS`);
  }
  
  /**
   * Create simulated option contracts
   * @param asset Asset
   */
  private createSimulatedOptionContracts(asset: string): void {
    // Generate base price for the asset
    let basePrice: number;
    
    switch (asset) {
      case 'BTC':
        basePrice = 50000 + (Math.random() * 5000); // $50,000-$55,000
        break;
      case 'ETH':
        basePrice = 3000 + (Math.random() * 500); // $3000-$3500
        break;
      case 'SOL':
        basePrice = 100 + (Math.random() * 20); // $100-$120
        break;
      default:
        basePrice = 100 + (Math.random() * 50); // $100-$150
    }
    
    // Generate expiry dates (1 week, 2 weeks, 1 month, 3 months)
    const now = new Date();
    const expiryDates = [
      new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000),
      new Date(now.getTime() + 14 * 24 * 60 * 60 * 1000),
      new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000),
      new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000)
    ];
    
    // Generate strike prices (70%, 80%, 90%, 100%, 110%, 120%, 130% of base price)
    const strikeMultipliers = [0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3];
    const strikes = strikeMultipliers.map(m => Math.round(basePrice * m / 10) * 10); // Round to nearest 10
    
    // Create option contracts for each exchange, expiry, strike, and option type
    for (const exchange of this.config.monitoredExchanges) {
      for (const expiryDate of expiryDates) {
        for (const strike of strikes) {
          // Create call option
          this.createSimulatedOptionContract(
            asset,
            'USD',
            exchange,
            OptionType.CALL,
            OptionStyle.EUROPEAN,
            strike,
            expiryDate,
            basePrice
          );
          
          // Create put option
          this.createSimulatedOptionContract(
            asset,
            'USD',
            exchange,
            OptionType.PUT,
            OptionStyle.EUROPEAN,
            strike,
            expiryDate,
            basePrice
          );
        }
      }
    }
  }  /**
  
 * Create simulated option contract
   * @param baseAsset Base asset
   * @param quoteAsset Quote asset
   * @param exchange Exchange
   * @param optionType Option type
   * @param optionStyle Option style
   * @param strike Strike price
   * @param expiryDate Expiry date
   * @param underlyingPrice Underlying price
   */
  private createSimulatedOptionContract(
    baseAsset: string,
    quoteAsset: string,
    exchange: Exchange,
    optionType: OptionType,
    optionStyle: OptionStyle,
    strike: number,
    expiryDate: Date,
    underlyingPrice: number
  ): void {
    // Generate symbol
    const expiryStr = expiryDate.toISOString().split('T')[0].replace(/-/g, '');
    const symbol = `${baseAsset}-${expiryStr}-${strike}-${optionType.toUpperCase()}`;
    
    // Calculate days to expiry
    const daysToExpiry = (expiryDate.getTime() - Date.now()) / (24 * 60 * 60 * 1000);
    
    // Generate implied volatility (different for each exchange and expiry)
    let baseIV: number;
    
    switch (baseAsset) {
      case 'BTC':
        baseIV = 0.7 + (Math.random() * 0.3); // 70-100% IV
        break;
      case 'ETH':
        baseIV = 0.8 + (Math.random() * 0.4); // 80-120% IV
        break;
      case 'SOL':
        baseIV = 1.0 + (Math.random() * 0.5); // 100-150% IV
        break;
      default:
        baseIV = 0.9 + (Math.random() * 0.4); // 90-130% IV
    }
    
    // Adjust IV based on exchange
    let exchangeIVMultiplier = 1.0;
    
    switch (exchange) {
      case Exchange.DERIBIT:
        exchangeIVMultiplier = 1.0;
        break;
      case Exchange.OKX:
        exchangeIVMultiplier = 1.05;
        break;
      case Exchange.BYBIT:
        exchangeIVMultiplier = 1.1;
        break;
      case Exchange.BINANCE:
        exchangeIVMultiplier = 1.15;
        break;
      default:
        exchangeIVMultiplier = 1.0;
    }
    
    // Adjust IV based on days to expiry (term structure)
    let expiryIVMultiplier = 1.0;
    
    if (daysToExpiry <= 7) {
      expiryIVMultiplier = 1.2; // Higher IV for short-dated options
    } else if (daysToExpiry <= 14) {
      expiryIVMultiplier = 1.1;
    } else if (daysToExpiry <= 30) {
      expiryIVMultiplier = 1.0;
    } else {
      expiryIVMultiplier = 0.9; // Lower IV for longer-dated options
    }
    
    // Adjust IV based on strike (volatility skew)
    let strikeIVMultiplier = 1.0;
    const moneyness = strike / underlyingPrice;
    
    if (optionType === OptionType.CALL) {
      if (moneyness < 0.9) {
        strikeIVMultiplier = 0.9; // Lower IV for deep ITM calls
      } else if (moneyness > 1.1) {
        strikeIVMultiplier = 1.1; // Higher IV for OTM calls
      }
    } else { // PUT
      if (moneyness < 0.9) {
        strikeIVMultiplier = 1.2; // Higher IV for OTM puts (crash protection)
      } else if (moneyness > 1.1) {
        strikeIVMultiplier = 0.95; // Lower IV for deep ITM puts
      }
    }
    
    // Calculate final IV
    const impliedVolatility = baseIV * exchangeIVMultiplier * expiryIVMultiplier * strikeIVMultiplier;
    
    // Calculate option price using Black-Scholes approximation
    const price = this.calculateOptionPrice(
      underlyingPrice,
      strike,
      daysToExpiry / 365, // time to expiry in years
      impliedVolatility,
      0.05, // risk-free rate
      optionType
    ); 
   // Calculate Greeks
    const delta = this.calculateDelta(
      underlyingPrice,
      strike,
      daysToExpiry / 365,
      impliedVolatility,
      0.05,
      optionType
    );
    
    const gamma = this.calculateGamma(
      underlyingPrice,
      strike,
      daysToExpiry / 365,
      impliedVolatility,
      0.05
    );
    
    const vega = this.calculateVega(
      underlyingPrice,
      strike,
      daysToExpiry / 365,
      impliedVolatility,
      0.05
    );
    
    const theta = this.calculateTheta(
      underlyingPrice,
      strike,
      daysToExpiry / 365,
      impliedVolatility,
      0.05,
      optionType
    );
    
    // Add some bid-ask spread
    const spread = price * 0.05; // 5% spread
    const bid = price - (spread / 2);
    const ask = price + (spread / 2);
    
    // Create option contract
    const contract: OptionContract = {
      exchange,
      symbol,
      baseAsset,
      quoteAsset,
      optionType,
      optionStyle,
      strike,
      expiryDate,
      lastPrice: price,
      markPrice: price,
      underlyingPrice,
      bid,
      ask,
      delta,
      gamma,
      vega,
      theta,
      impliedVolatility,
      openInterest: 100 + Math.floor(Math.random() * 900), // 100-1000 contracts
      volume24h: 10 + Math.floor(Math.random() * 90), // 10-100 contracts
      lastUpdated: new Date()
    };
    
    // Store contract
    const key = `${exchange}_${symbol}`;
    this.optionContracts.set(key, contract);
  }
  
  /**
   * Calculate option price using Black-Scholes approximation
   * @param s Underlying price
   * @param k Strike price
   * @param t Time to expiry in years
   * @param v Implied volatility
   * @param r Risk-free rate
   * @param optionType Option type
   * @returns Option price
   */
  private calculateOptionPrice(
    s: number,
    k: number,
    t: number,
    v: number,
    r: number,
    optionType: OptionType
  ): number {
    // Black-Scholes formula
    const d1 = (Math.log(s / k) + (r + v * v / 2) * t) / (v * Math.sqrt(t));
    const d2 = d1 - v * Math.sqrt(t);
    
    if (optionType === OptionType.CALL) {
      return s * this.normalCDF(d1) - k * Math.exp(-r * t) * this.normalCDF(d2);
    } else {
      return k * Math.exp(-r * t) * this.normalCDF(-d2) - s * this.normalCDF(-d1);
    }
  } 
 /**
   * Calculate delta
   * @param s Underlying price
   * @param k Strike price
   * @param t Time to expiry in years
   * @param v Implied volatility
   * @param r Risk-free rate
   * @param optionType Option type
   * @returns Delta
   */
  private calculateDelta(
    s: number,
    k: number,
    t: number,
    v: number,
    r: number,
    optionType: OptionType
  ): number {
    const d1 = (Math.log(s / k) + (r + v * v / 2) * t) / (v * Math.sqrt(t));
    
    if (optionType === OptionType.CALL) {
      return this.normalCDF(d1);
    } else {
      return this.normalCDF(d1) - 1;
    }
  }
  
  /**
   * Calculate gamma
   * @param s Underlying price
   * @param k Strike price
   * @param t Time to expiry in years
   * @param v Implied volatility
   * @param r Risk-free rate
   * @returns Gamma
   */
  private calculateGamma(
    s: number,
    k: number,
    t: number,
    v: number,
    r: number
  ): number {
    const d1 = (Math.log(s / k) + (r + v * v / 2) * t) / (v * Math.sqrt(t));
    return this.normalPDF(d1) / (s * v * Math.sqrt(t));
  }
  
  /**
   * Calculate vega
   * @param s Underlying price
   * @param k Strike price
   * @param t Time to expiry in years
   * @param v Implied volatility
   * @param r Risk-free rate
   * @returns Vega
   */
  private calculateVega(
    s: number,
    k: number,
    t: number,
    v: number,
    r: number
  ): number {
    const d1 = (Math.log(s / k) + (r + v * v / 2) * t) / (v * Math.sqrt(t));
    return s * Math.sqrt(t) * this.normalPDF(d1) * 0.01; // Vega is for 1% change in IV
  }
  
  /**
   * Calculate theta
   * @param s Underlying price
   * @param k Strike price
   * @param t Time to expiry in years
   * @param v Implied volatility
   * @param r Risk-free rate
   * @param optionType Option type
   * @returns Theta
   */
  private calculateTheta(
    s: number,
    k: number,
    t: number,
    v: number,
    r: number,
    optionType: OptionType
  ): number {
    const d1 = (Math.log(s / k) + (r + v * v / 2) * t) / (v * Math.sqrt(t));
    const d2 = d1 - v * Math.sqrt(t);
    
    const term1 = -s * this.normalPDF(d1) * v / (2 * Math.sqrt(t));
    
    if (optionType === OptionType.CALL) {
      const term2 = -r * k * Math.exp(-r * t) * this.normalCDF(d2);
      return (term1 + term2) / 365; // Daily theta
    } else {
      const term2 = r * k * Math.exp(-r * t) * this.normalCDF(-d2);
      return (term1 + term2) / 365; // Daily theta
    }
  }  /
**
   * Normal cumulative distribution function
   * @param x Value
   * @returns CDF value
   */
  private normalCDF(x: number): number {
    // Approximation of the normal CDF
    const t = 1 / (1 + 0.2316419 * Math.abs(x));
    const d = 0.3989423 * Math.exp(-x * x / 2);
    const p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - p : p;
  }
  
  /**
   * Normal probability density function
   * @param x Value
   * @returns PDF value
   */
  private normalPDF(x: number): number {
    return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
  }
  
  /**
   * Start options monitoring
   */
  private startOptionsMonitoring(): void {
    console.log('📡 STARTING OPTIONS MONITORING...');
    
    // In a real implementation, this would connect to exchange APIs
    // For now, we'll simulate price updates
    
    // Update prices every 10 seconds
    setInterval(() => {
      for (const [key, contract] of this.optionContracts.entries()) {
        this.updateOptionPrice(key, contract);
      }
    }, 10000);
    
    // Listen for spot price updates from exchange manager
    this.exchangeManager.on('priceUpdate', (priceUpdate) => {
      // Extract base asset
      const baseAsset = priceUpdate.symbol.split('/')[0];
      
      // Update option contracts for this asset
      for (const [key, contract] of this.optionContracts.entries()) {
        if (contract.baseAsset === baseAsset) {
          this.updateOptionPrice(key, contract, priceUpdate.price);
        }
      }
    });
    
    // Build volatility surfaces
    this.buildVolatilitySurfaces();
  }
  
  /**
   * Update option price
   * @param key Contract key
   * @param contract Option contract
   * @param newUnderlyingPrice New underlying price
   */
  private updateOptionPrice(
    key: string,
    contract: OptionContract,
    newUnderlyingPrice?: number
  ): void {
    // Get underlying price
    const underlyingPrice = newUnderlyingPrice || contract.underlyingPrice;
    
    // Update underlying price
    contract.underlyingPrice = underlyingPrice;
    
    // Calculate days to expiry
    const daysToExpiry = (contract.expiryDate.getTime() - Date.now()) / (24 * 60 * 60 * 1000);
    
    // Skip if expired
    if (daysToExpiry <= 0) {
      return;
    }
    
    // Update implied volatility (small random changes)
    let newIV = contract.impliedVolatility;
    newIV += (Math.random() * 0.02) - 0.01; // -1% to +1% change
    newIV = Math.max(0.1, Math.min(2.0, newIV)); // Cap between 10% and 200%
    
    // Calculate new option price
    const newPrice = this.calculateOptionPrice(
      underlyingPrice,
      contract.strike,
      daysToExpiry / 365,
      newIV,
      0.05,
      contract.optionType
    );   
 // Update Greeks
    const delta = this.calculateDelta(
      underlyingPrice,
      contract.strike,
      daysToExpiry / 365,
      newIV,
      0.05,
      contract.optionType
    );
    
    const gamma = this.calculateGamma(
      underlyingPrice,
      contract.strike,
      daysToExpiry / 365,
      newIV,
      0.05
    );
    
    const vega = this.calculateVega(
      underlyingPrice,
      contract.strike,
      daysToExpiry / 365,
      newIV,
      0.05
    );
    
    const theta = this.calculateTheta(
      underlyingPrice,
      contract.strike,
      daysToExpiry / 365,
      newIV,
      0.05,
      contract.optionType
    );
    
    // Add some bid-ask spread
    const spread = newPrice * 0.05; // 5% spread
    const bid = newPrice - (spread / 2);
    const ask = newPrice + (spread / 2);
    
    // Update contract
    contract.markPrice = newPrice;
    contract.lastPrice = newPrice;
    contract.bid = bid;
    contract.ask = ask;
    contract.delta = delta;
    contract.gamma = gamma;
    contract.vega = vega;
    contract.theta = theta;
    contract.impliedVolatility = newIV;
    contract.lastUpdated = new Date();
    
    // Store updated contract
    this.optionContracts.set(key, contract);
    
    // Update active trades
    this.updateActiveTrades();
  }
  
  /**
   * Build volatility surfaces
   */
  private buildVolatilitySurfaces(): void {
    console.log('📊 BUILDING VOLATILITY SURFACES...');
    
    // Group contracts by asset and exchange
    const contractsByAssetExchange = new Map<string, OptionContract[]>();
    
    for (const contract of this.optionContracts.values()) {
      const key = `${contract.baseAsset}_${contract.exchange}`;
      const contracts = contractsByAssetExchange.get(key) || [];
      contracts.push(contract);
      contractsByAssetExchange.set(key, contracts);
    }
    
    // Build volatility surface for each asset/exchange
    for (const [key, contracts] of contractsByAssetExchange.entries()) {
      const [baseAsset, exchange] = key.split('_');
      
      // Extract unique expiry dates and strikes
      const expiryDates = Array.from(new Set(contracts.map(c => c.expiryDate)));
      const strikes = Array.from(new Set(contracts.map(c => c.strike)));
      
      // Sort expiry dates and strikes
      expiryDates.sort((a, b) => a.getTime() - b.getTime());
      strikes.sort((a, b) => a - b);
      
      // Create maps for implied volatilities, skew, and term structure
      const impliedVolatilities = new Map<string, number>();
      const skew = new Map<string, number>();
      const term = new Map<number, number>();
      
      // Populate implied volatilities
      for (const contract of contracts) {
        const key = `${contract.expiryDate.toISOString()}_${contract.strike}`;
        impliedVolatilities.set(key, contract.impliedVolatility);
      }      /
/ Calculate skew for each expiry (ATM IV - OTM Put IV)
      for (const expiry of expiryDates) {
        const expiryContracts = contracts.filter(c => c.expiryDate.getTime() === expiry.getTime());
        const atmStrike = this.findAtmStrike(expiryContracts);
        
        const atmCall = expiryContracts.find(c => c.strike === atmStrike && c.optionType === OptionType.CALL);
        const otmPut = expiryContracts.find(c => c.strike === atmStrike * 0.9 && c.optionType === OptionType.PUT);
        
        if (atmCall && otmPut) {
          const skewValue = otmPut.impliedVolatility - atmCall.impliedVolatility;
          skew.set(expiry.toISOString(), skewValue);
        }
      }
      
      // Calculate term structure (IV by days to expiry)
      for (const expiry of expiryDates) {
        const daysToExpiry = (expiry.getTime() - Date.now()) / (24 * 60 * 60 * 1000);
        const expiryContracts = contracts.filter(c => c.expiryDate.getTime() === expiry.getTime());
        const atmStrike = this.findAtmStrike(expiryContracts);
        
        const atmCall = expiryContracts.find(c => c.strike === atmStrike && c.optionType === OptionType.CALL);
        
        if (atmCall) {
          term.set(Math.round(daysToExpiry), atmCall.impliedVolatility);
        }
      }
      
      // Create volatility surface
      const volatilitySurface: VolatilitySurface = {
        baseAsset,
        exchange: exchange as Exchange,
        timestamp: new Date(),
        expiryDates,
        strikes,
        impliedVolatilities,
        skew,
        term
      };
      
      // Store volatility surface
      this.volatilitySurfaces.set(key, volatilitySurface);
    }
    
    console.log(`✅ BUILT ${this.volatilitySurfaces.size} VOLATILITY SURFACES`);
  }
  
  /**
   * Find ATM strike
   * @param contracts Option contracts
   * @returns ATM strike
   */
  private findAtmStrike(contracts: OptionContract[]): number {
    if (contracts.length === 0) {
      return 0;
    }
    
    const underlyingPrice = contracts[0].underlyingPrice;
    const strikes = Array.from(new Set(contracts.map(c => c.strike)));
    
    // Find closest strike to underlying price
    return strikes.reduce((closest, current) => {
      return Math.abs(current - underlyingPrice) < Math.abs(closest - underlyingPrice) ? current : closest;
    }, strikes[0]);
  }
  
  /**
   * Start opportunity scan
   */
  private startOpportunityScan(): void {
    console.log('🔍 STARTING OPPORTUNITY SCAN...');
    
    // Scan for opportunities immediately
    this.scanForOpportunities();
    
    // Set up interval for regular opportunity scanning
    this.scanInterval = setInterval(() => {
      this.scanForOpportunities();
    }, this.config.scanIntervalMs);
  } 
 /**
   * Scan for opportunities
   */
  private scanForOpportunities(): void {
    console.log('🔍 SCANNING FOR OPTIONS LEVERAGE OPPORTUNITIES...');
    
    // Scan for long call opportunities
    if (this.config.preferredStrategies.includes(OptionsStrategy.LONG_CALL)) {
      this.scanForLongCallOpportunities();
    }
    
    // Scan for long put opportunities
    if (this.config.preferredStrategies.includes(OptionsStrategy.LONG_PUT)) {
      this.scanForLongPutOpportunities();
    }
    
    // Scan for call spread opportunities
    if (this.config.preferredStrategies.includes(OptionsStrategy.CALL_SPREAD)) {
      this.scanForCallSpreadOpportunities();
    }
    
    // Scan for put spread opportunities
    if (this.config.preferredStrategies.includes(OptionsStrategy.PUT_SPREAD)) {
      this.scanForPutSpreadOpportunities();
    }
    
    // Update existing opportunities
    this.updateOpportunities();
  }
  
  /**
   * Scan for long call opportunities
   */
  private scanForLongCallOpportunities(): void {
    // Group contracts by asset and exchange
    const contractsByAssetExchange = new Map<string, OptionContract[]>();
    
    for (const contract of this.optionContracts.values()) {
      // Only consider call options
      if (contract.optionType !== OptionType.CALL) {
        continue;
      }
      
      const key = `${contract.baseAsset}_${contract.exchange}`;
      const contracts = contractsByAssetExchange.get(key) || [];
      contracts.push(contract);
      contractsByAssetExchange.set(key, contracts);
    }
    
    // Check each asset/exchange for opportunities
    for (const [key, contracts] of contractsByAssetExchange.entries()) {
      const [baseAsset, exchangeStr] = key.split('_');
      const exchange = exchangeStr as Exchange;
      
      // Get volatility surface
      const volSurface = this.volatilitySurfaces.get(key);
      
      // Filter contracts by days to expiry
      const validContracts = contracts.filter(c => {
        const daysToExpiry = (c.expiryDate.getTime() - Date.now()) / (24 * 60 * 60 * 1000);
        return daysToExpiry >= this.config.daysToExpiryMin && daysToExpiry <= this.config.daysToExpiryMax;
      });
      
      // Look for out-of-the-money calls with high leverage potential
      for (const contract of validContracts) {
        // Calculate moneyness
        const moneyness = contract.strike / contract.underlyingPrice;
        
        // Only consider slightly OTM calls (5-20% OTM)
        if (moneyness < 1.05 || moneyness > 1.2) {
          continue;
        }
        
        // Calculate days to expiry
        const daysToExpiry = (contract.expiryDate.getTime() - Date.now()) / (24 * 60 * 60 * 1000);
        
        // Calculate effective leverage
        const effectiveLeverage = (contract.delta * contract.underlyingPrice) / contract.markPrice;
        
        // Skip if leverage is too low
        if (effectiveLeverage < this.config.minEffectiveLeverage) {
          continue;
        }   
     // Calculate maximum return potential (assuming price moves to strike)
        const maxReturn = ((contract.strike - contract.underlyingPrice) / contract.markPrice) * 100;
        
        // Calculate break-even price
        const breakEvenPrice = contract.strike + contract.markPrice;
        
        // Calculate probability of profit using delta as approximation
        const probabilityOfProfit = contract.delta;
        
        // Skip if probability is too low
        if (probabilityOfProfit < this.config.minProbabilityOfProfit) {
          continue;
        }
        
        // Calculate risk-reward ratio
        const riskRewardRatio = maxReturn / 100; // Risk is 100% of premium
        
        // Skip if risk-reward is too low
        if (riskRewardRatio < this.config.minRiskRewardRatio) {
          continue;
        }
        
        // Calculate IV percentile if volatility surface is available
        let ivPercentile = 0.5; // Default to middle
        let volatilitySkew = 0;
        let historicalVolatility = contract.impliedVolatility * 0.9; // Estimate
        
        if (volSurface) {
          // Calculate IV percentile based on term structure
          const termIVs = Array.from(volSurface.term.values());
          if (termIVs.length > 0) {
            const sortedIVs = [...termIVs].sort((a, b) => a - b);
            const rank = sortedIVs.findIndex(iv => iv >= contract.impliedVolatility);
            ivPercentile = rank / sortedIVs.length;
          }
          
          // Get volatility skew
          const skewValue = volSurface.skew.get(contract.expiryDate.toISOString());
          if (skewValue !== undefined) {
            volatilitySkew = skewValue;
          }
          
          // Estimate historical volatility
          historicalVolatility = contract.impliedVolatility * (0.8 + (Math.random() * 0.4)); // 80-120% of IV
        }
        
        // Skip if IV is too high (unless we're specifically looking for high IV)
        if (ivPercentile > this.config.volatilityPercentileThreshold / 100) {
          continue;
        }
        
        // Calculate confidence based on multiple factors
        let confidence = 0.7; // Base confidence
        
        // Adjust confidence based on leverage (higher leverage = lower confidence)
        confidence -= Math.min(0.2, (effectiveLeverage / 100) * 0.2); // Up to -0.2 for high leverage
        
        // Adjust confidence based on probability of profit
        confidence += Math.min(0.15, probabilityOfProfit * 0.15); // Up to +0.15 for high probability
        
        // Adjust confidence based on IV percentile (lower IV = higher confidence)
        confidence += Math.min(0.15, (1 - ivPercentile) * 0.15); // Up to +0.15 for low IV
        
        // Adjust confidence based on liquidity
        const liquidityFactor = Math.min(1, contract.openInterest / 1000); // Cap at 1000 open interest
        confidence += liquidityFactor * 0.1; // Up to +0.1 for high liquidity
        
        // Cap confidence at 0.95
        confidence = Math.min(0.95, confidence);
        
        // Skip if confidence is too low
        if (confidence < this.config.minConfidence) {
          continue;
        }      
  // Check if we already have an active opportunity for this contract
        const existingOpportunity = Array.from(this.opportunities.values())
          .find(o => o.contract.symbol === contract.symbol && 
                    o.exchange === contract.exchange && 
                    o.status === 'active');
        
        if (existingOpportunity) {
          // Update existing opportunity
          existingOpportunity.underlyingPrice = contract.underlyingPrice;
          existingOpportunity.effectiveLeverage = effectiveLeverage;
          existingOpportunity.maxReturn = maxReturn;
          existingOpportunity.breakEvenPrice = breakEvenPrice;
          existingOpportunity.probabilityOfProfit = probabilityOfProfit;
          existingOpportunity.riskRewardRatio = riskRewardRatio;
          existingOpportunity.confidence = confidence;
          
          // Store updated opportunity
          this.opportunities.set(existingOpportunity.id, existingOpportunity);
          continue;
        }
        
        // Create new opportunity
        const opportunity: OptionsLeverageOpportunity = {
          id: uuidv4(),
          baseAsset,
          quoteAsset: contract.quoteAsset,
          exchange: contract.exchange,
          contract,
          underlyingPrice: contract.underlyingPrice,
          effectiveLeverage,
          maxReturn,
          maxLoss: 100, // 100% of premium
          breakEvenPrice,
          probabilityOfProfit,
          riskRewardRatio,
          daysToExpiry,
          impliedVolatility: contract.impliedVolatility,
          historicalVolatility,
          volatilitySkew,
          ivPercentile,
          confidence,
          strategy: OptionsStrategy.LONG_CALL,
          detectedAt: new Date(),
          status: 'active',
          notes: [
            `Detected ${effectiveLeverage.toFixed(1)}x leverage opportunity with ${maxReturn.toFixed(2)}% max return`,
            `Strike: ${contract.strike}, Expiry: ${contract.expiryDate.toISOString().split('T')[0]}`,
            `IV: ${(contract.impliedVolatility * 100).toFixed(2)}%, IV Percentile: ${(ivPercentile * 100).toFixed(2)}%`,
            `Probability of Profit: ${(probabilityOfProfit * 100).toFixed(2)}%, Risk-Reward: ${riskRewardRatio.toFixed(2)}:1`,
            `Confidence: ${(confidence * 100).toFixed(2)}%`
          ]
        };
        
        // Store opportunity
        this.opportunities.set(opportunity.id, opportunity);
        
        console.log(`💰 LONG CALL OPPORTUNITY DETECTED: ${baseAsset} on ${contract.exchange}`);
        console.log(`📊 ${effectiveLeverage.toFixed(1)}x leverage, ${maxReturn.toFixed(2)}% max return`);
        console.log(`📊 Strike: ${contract.strike}, Expiry: ${contract.expiryDate.toISOString().split('T')[0]}`);
        
        // Emit opportunity detected event
        this.emit('opportunityDetected', opportunity);
        
        // Create trade if confidence is high enough
        if (confidence >= this.config.minConfidence) {
          this.createOptionsTrade(opportunity);
        }
      }
    }
  }  /
**
   * Scan for long put opportunities
   */
  private scanForLongPutOpportunities(): void {
    // Implementation similar to scanForLongCallOpportunities but for puts
    // For brevity, this is omitted in this example
  }
  
  /**
   * Scan for call spread opportunities
   */
  private scanForCallSpreadOpportunities(): void {
    // Implementation for call spreads
    // For brevity, this is omitted in this example
  }
  
  /**
   * Scan for put spread opportunities
   */
  private scanForPutSpreadOpportunities(): void {
    // Implementation for put spreads
    // For brevity, this is omitted in this example
  }
  
  /**
   * Update opportunities
   */
  private updateOpportunities(): void {
    // Update status of existing opportunities
    for (const opportunity of this.opportunities.values()) {
      // Skip non-active opportunities
      if (opportunity.status !== 'active') {
        continue;
      }
      
      // Check if contract has expired
      const now = new Date();
      if (now >= opportunity.contract.expiryDate) {
        opportunity.status = 'expired';
        continue;
      }
      
      // Update days to expiry
      opportunity.daysToExpiry = (opportunity.contract.expiryDate.getTime() - now.getTime()) / (24 * 60 * 60 * 1000);
    }
  }
  
  /**
   * Update active trades
   */
  private updateActiveTrades(): void {
    // Update status of active trades
    for (const trade of this.activeTrades.values()) {
      // Skip non-active trades
      if (trade.status !== 'active') {
        continue;
      }
      
      // Calculate current value of each leg
      let currentValue = 0;
      
      for (const leg of trade.legs) {
        // Get current contract
        const contract = this.getContractByExchangeAndSymbol(leg.contract.exchange, leg.contract.symbol);
        
        if (!contract) {
          continue;
        }
        
        // Calculate current value based on action
        if (leg.action === 'buy') {
          leg.currentValue = contract.markPrice * leg.quantity;
          currentValue += leg.currentValue;
        } else {
          leg.currentValue = (leg.price - contract.markPrice) * leg.quantity;
          currentValue += leg.currentValue;
        }
      }
      
      // Update trade
      trade.currentValue = currentValue;
      trade.currentUnderlyingPrice = trade.legs[0]?.contract.underlyingPrice || trade.initialUnderlyingPrice;
      
      // Calculate P&L
      trade.pnl = trade.currentValue - trade.premium;
      trade.pnlPercentage = (trade.pnl / trade.premium) * 100;
      
      // Check if any legs have expired
      const now = new Date();
      const allExpired = trade.legs.every(leg => now >= leg.contract.expiryDate);
      
      if (allExpired) {
        this.closeTrade(trade, 'expiry');
      }
    }
  }  /**

   * Get contract by exchange and symbol
   * @param exchange Exchange
   * @param symbol Symbol
   * @returns Option contract
   */
  private getContractByExchangeAndSymbol(exchange: Exchange, symbol: string): OptionContract | null {
    const key = `${exchange}_${symbol}`;
    return this.optionContracts.get(key) || null;
  }
  
  /**
   * Create options trade
   * @param opportunity Options leverage opportunity
   */
  private createOptionsTrade(opportunity: OptionsLeverageOpportunity): void {
    // Check if we already have too many active trades
    if (this.activeTrades.size >= this.config.maxActiveTrades) {
      console.log(`⚠️ Maximum active trades (${this.config.maxActiveTrades}) reached, skipping trade`);
      return;
    }
    
    console.log(`💰 CREATING OPTIONS LEVERAGE TRADE: ${opportunity.baseAsset} on ${opportunity.exchange}`);
    
    // Calculate position size based on available capital and risk
    const positionSize = this.calculatePositionSize(opportunity);
    
    // Create trade based on strategy
    let trade: OptionsTrade;
    
    switch (opportunity.strategy) {
      case OptionsStrategy.LONG_CALL:
        trade = this.createLongCallTrade(opportunity, positionSize);
        break;
      case OptionsStrategy.LONG_PUT:
        trade = this.createLongPutTrade(opportunity, positionSize);
        break;
      case OptionsStrategy.CALL_SPREAD:
        trade = this.createCallSpreadTrade(opportunity, positionSize);
        break;
      case OptionsStrategy.PUT_SPREAD:
        trade = this.createPutSpreadTrade(opportunity, positionSize);
        break;
      default:
        throw new Error(`Unsupported strategy: ${opportunity.strategy}`);
    }
    
    // Store trade
    this.activeTrades.set(trade.id, trade);
    
    // Update opportunity status
    opportunity.status = 'executed';
    this.opportunities.set(opportunity.id, opportunity);
    
    console.log(`📊 TRADE CREATED: ${opportunity.strategy} on ${opportunity.exchange}`);
    console.log(`📊 Size: ${positionSize}, Premium: ${trade.premium.toFixed(2)}, Max Profit: ${trade.maxProfit.toFixed(2)}`);
    
    // Emit trade created event
    this.emit('tradeCreated', trade);
    
    // Execute trade
    this.executeTrade(trade);
  }
  
  /**
   * Calculate position size
   * @param opportunity Options leverage opportunity
   * @returns Position size
   */
  private calculatePositionSize(opportunity: OptionsLeverageOpportunity): number {
    // Calculate maximum position size based on available capital and max position size
    const maxCapital = Math.min(this.accountBalance * 0.1, this.config.maxPositionSizeUsd);
    
    // Calculate contracts based on premium
    const contractPrice = opportunity.contract.markPrice;
    const maxContracts = Math.floor(maxCapital / contractPrice);
    
    // Adjust position size based on confidence
    const confidenceMultiplier = 0.5 + (opportunity.confidence * 0.5); // 0.5-1.0 based on confidence
    
    // Adjust position size based on leverage (higher leverage = smaller position)
    const leverageMultiplier = 1.0 - Math.min(0.5, (opportunity.effectiveLeverage / 100)); // 0.5-1.0 based on leverage
    
    // Calculate final position size
    const positionSize = Math.floor(maxContracts * confidenceMultiplier * leverageMultiplier);
    
    // Ensure at least 1 contract
    return Math.max(1, positionSize);
  }  /**

   * Create long call trade
   * @param opportunity Options leverage opportunity
   * @param positionSize Position size
   * @returns Options trade
   */
  private createLongCallTrade(opportunity: OptionsLeverageOpportunity, positionSize: number): OptionsTrade {
    const contract = opportunity.contract;
    
    // Calculate premium
    const premium = contract.markPrice * positionSize;
    
    // Calculate max profit (unlimited, but use 100% price increase as estimate)
    const estimatedPriceIncrease = contract.underlyingPrice * 2;
    const estimatedProfit = Math.max(0, estimatedPriceIncrease - contract.strike) * positionSize - premium;
    const maxProfit = estimatedProfit > 0 ? estimatedProfit : Infinity;
    
    // Calculate max loss (limited to premium)
    const maxLoss = premium;
    
    // Create trade
    const trade: OptionsTrade = {
      id: uuidv4(),
      opportunityId: opportunity.id,
      baseAsset: opportunity.baseAsset,
      quoteAsset: opportunity.quoteAsset,
      exchange: opportunity.exchange,
      strategy: OptionsStrategy.LONG_CALL,
      legs: [
        {
          contract,
          action: 'buy',
          quantity: positionSize,
          price: contract.markPrice,
          executed: false,
          executionTime: null,
          currentValue: contract.markPrice * positionSize
        }
      ],
      premium,
      maxProfit,
      maxLoss,
      breakEvenPrice: opportunity.breakEvenPrice,
      effectiveLeverage: opportunity.effectiveLeverage,
      initialUnderlyingPrice: contract.underlyingPrice,
      currentUnderlyingPrice: contract.underlyingPrice,
      currentValue: premium,
      pnl: 0,
      pnlPercentage: 0,
      status: 'pending',
      entryTime: null,
      exitTime: null,
      notes: [
        `Created ${OptionsStrategy.LONG_CALL} trade for ${opportunity.baseAsset}`,
        `Strike: ${contract.strike}, Expiry: ${contract.expiryDate.toISOString().split('T')[0]}`,
        `Premium: ${premium.toFixed(2)}, Effective Leverage: ${opportunity.effectiveLeverage.toFixed(1)}x`
      ]
    };
    
    return trade;
  }
  
  /**
   * Create long put trade
   * @param opportunity Options leverage opportunity
   * @param positionSize Position size
   * @returns Options trade
   */
  private createLongPutTrade(opportunity: OptionsLeverageOpportunity, positionSize: number): OptionsTrade {
    // Implementation similar to createLongCallTrade but for puts
    // For brevity, this is omitted in this example
    return {} as OptionsTrade;
  }
  
  /**
   * Create call spread trade
   * @param opportunity Options leverage opportunity
   * @param positionSize Position size
   * @returns Options trade
   */
  private createCallSpreadTrade(opportunity: OptionsLeverageOpportunity, positionSize: number): OptionsTrade {
    // Implementation for call spreads
    // For brevity, this is omitted in this example
    return {} as OptionsTrade;
  }
  
  /**
   * Create put spread trade
   * @param opportunity Options leverage opportunity
   * @param positionSize Position size
   * @returns Options trade
   */
  private createPutSpreadTrade(opportunity: OptionsLeverageOpportunity, positionSize: number): OptionsTrade {
    // Implementation for put spreads
    // For brevity, this is omitted in this example
    return {} as OptionsTrade;
  }  /
**
   * Execute trade
   * @param trade Options trade
   */
  private async executeTrade(trade: OptionsTrade): Promise<void> {
    console.log(`⚡ EXECUTING OPTIONS LEVERAGE TRADE: ${trade.baseAsset}...`);
    
    try {
      // In a real implementation, this would execute the trades on the exchanges
      // For now, we'll simulate execution
      
      // Execute each leg
      for (const leg of trade.legs) {
        leg.executed = true;
        leg.executionTime = new Date();
      }
      
      // Update trade status
      trade.status = 'active';
      trade.entryTime = new Date();
      
      // Add note
      trade.notes.push(`Executed trade at ${new Date().toISOString()}`);
      
      console.log(`✅ TRADE EXECUTED: ${trade.strategy} on ${trade.exchange}`);
      
      // Emit trade executed event
      this.emit('tradeExecuted', trade);
      
    } catch (error) {
      console.error(`❌ ERROR EXECUTING TRADE: ${error}`);
      
      // Update trade status
      trade.status = 'failed';
      trade.notes.push(`Trade failed: ${error}`);
      
      // Emit trade failed event
      this.emit('tradeFailed', trade, error);
    }
  }
  
  /**
   * Close trade
   * @param trade Options trade
   * @param reason Close reason
   */
  private async closeTrade(trade: OptionsTrade, reason: 'profit_target' | 'stop_loss' | 'expiry' | 'manual'): Promise<void> {
    console.log(`⚡ CLOSING OPTIONS LEVERAGE TRADE: ${trade.baseAsset}...`);
    
    try {
      // In a real implementation, this would close the positions on the exchanges
      // For now, we'll simulate closing
      
      // Update trade
      trade.status = 'completed';
      trade.exitTime = new Date();
      
      // Add note
      trade.notes.push(`Closed trade at ${new Date().toISOString()} (${reason})`);
      trade.notes.push(`Final P&L: ${trade.pnl.toFixed(2)} (${trade.pnlPercentage.toFixed(2)}%)`);
      
      console.log(`✅ TRADE CLOSED: ${trade.baseAsset}`);
      console.log(`💰 P&L: ${trade.pnl.toFixed(2)} (${trade.pnlPercentage.toFixed(2)}%)`);
      
      // Move to completed trades
      this.completedTrades.push(trade);
      this.activeTrades.delete(trade.id);
      
      // Emit trade closed event
      this.emit('tradeClosed', trade);
      
    } catch (error) {
      console.error(`❌ ERROR CLOSING TRADE: ${error}`);
      
      // Add note
      trade.notes.push(`Close failed: ${error}`);
      
      // Emit close failed event
      this.emit('closeFailed', trade, error);
    }
  }
  
  /**
   * Get option contracts
   * @returns Option contracts
   */
  getOptionContracts(): OptionContract[] {
    return Array.from(this.optionContracts.values());
  }
  
  /**
   * Get opportunities
   * @returns Options leverage opportunities
   */
  getOpportunities(): OptionsLeverageOpportunity[] {
    return Array.from(this.opportunities.values());
  }
  
  /**
   * Get active trades
   * @returns Active trades
   */
  getActiveTrades(): OptionsTrade[] {
    return Array.from(this.activeTrades.values());
  }
  
  /**
   * Get completed trades
   * @returns Completed trades
   */
  getCompletedTrades(): OptionsTrade[] {
    return this.completedTrades;
  } 
 /**
   * Get statistics
   * @returns Statistics
   */
  getStatistics(): any {
    // Calculate success rate
    const successfulTrades = this.completedTrades.filter(t => t.pnl > 0);
    const successRate = this.completedTrades.length > 0
      ? successfulTrades.length / this.completedTrades.length
      : 0;
    
    // Calculate average profit
    const totalPnl = this.completedTrades.reduce((sum, t) => sum + t.pnl, 0);
    const avgPnl = this.completedTrades.length > 0
      ? totalPnl / this.completedTrades.length
      : 0;
    
    // Calculate average profit percentage
    const totalPnlPercentage = this.completedTrades.reduce((sum, t) => sum + t.pnlPercentage, 0);
    const avgPnlPercentage = this.completedTrades.length > 0
      ? totalPnlPercentage / this.completedTrades.length
      : 0;
    
    // Calculate average leverage
    const totalLeverage = this.completedTrades.reduce((sum, t) => sum + t.effectiveLeverage, 0);
    const avgLeverage = this.completedTrades.length > 0
      ? totalLeverage / this.completedTrades.length
      : 0;
    
    // Calculate strategy statistics
    const strategyStats = new Map<OptionsStrategy, { trades: number, successRate: number, avgPnl: number }>();
    
    for (const strategy of Object.values(OptionsStrategy)) {
      const strategyTrades = this.completedTrades.filter(t => t.strategy === strategy);
      const strategySuccessfulTrades = strategyTrades.filter(t => t.pnl > 0);
      const strategyTotalPnl = strategyTrades.reduce((sum, t) => sum + t.pnl, 0);
      
      strategyStats.set(strategy as OptionsStrategy, {
        trades: strategyTrades.length,
        successRate: strategyTrades.length > 0 ? strategySuccessfulTrades.length / strategyTrades.length : 0,
        avgPnl: strategyTrades.length > 0 ? strategyTotalPnl / strategyTrades.length : 0
      });
    }
    
    // Calculate asset statistics
    const assetStats = new Map<string, { trades: number, successRate: number, avgPnl: number }>();
    
    for (const asset of this.monitoredAssets) {
      const assetTrades = this.completedTrades.filter(t => t.baseAsset === asset);
      const assetSuccessfulTrades = assetTrades.filter(t => t.pnl > 0);
      const assetTotalPnl = assetTrades.reduce((sum, t) => sum + t.pnl, 0);
      
      assetStats.set(asset, {
        trades: assetTrades.length,
        successRate: assetTrades.length > 0 ? assetSuccessfulTrades.length / assetTrades.length : 0,
        avgPnl: assetTrades.length > 0 ? assetTotalPnl / assetTrades.length : 0
      });
    }
    
    return {
      monitoredAssets: this.monitoredAssets.length,
      monitoredExchanges: this.config.monitoredExchanges.length,
      optionContracts: this.optionContracts.size,
      opportunities: this.opportunities.size,
      activeTrades: this.activeTrades.size,
      completedTrades: this.completedTrades.length,
      successfulTrades: successfulTrades.length,
      failedTrades: this.completedTrades.length - successfulTrades.length,
      successRate: successRate * 100,
      totalPnl,
      avgPnl,
      avgPnlPercentage,
      avgLeverage,
      strategyStats: Object.fromEntries(strategyStats),
      assetStats: Object.fromEntries(assetStats),
      isRunning: this.isRunning,
      config: this.config
    };
  }
  
  /**
   * Update configuration
   * @param config New configuration
   */
  updateConfig(config: Partial<OptionsLeverageConfig>): void {
    this.config = { ...this.config, ...config };
    console.log('⚙️ Updated options leverage configuration');
  }
  
  /**
   * Stop the options leverage exploitation system
   */
  stop(): void {
    console.log('🛑 STOPPING OPTIONS LEVERAGE EXPLOITATION SYSTEM...');
    
    // Clear scan interval
    if (this.scanInterval) {
      clearInterval(this.scanInterval);
      this.scanInterval = null;
    }
    
    this.isRunning = false;
    console.log('🛑 OPTIONS LEVERAGE EXPLOITATION SYSTEM STOPPED');
  }
}

export default OptionsLeverageExploitation;