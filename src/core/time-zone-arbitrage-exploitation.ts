// TIME ZONE ARBITRAGE EXPLOITATION SYSTEM - REVOLUTIONARY MARKET TRANSITION EXPLOITATION
// Exploit price gaps during market transitions between Asia, Europe, and US trading sessions

import { EventEmitter } from 'events';
import { v4 as uuidv4 } from 'uuid';
import ExchangeManager from '../exchanges/exchange-manager';
import { TradeSignal, TimeZoneArbitrage } from '../types/core';

/**
 * Market region
 */
export enum MarketRegion {
  ASIA = 'asia',
  EUROPE = 'europe',
  AMERICAS = 'americas'
}

/**
 * Exchange with region
 */
export interface ExchangeWithRegion {
  exchange: string;
  region: MarketRegion;
  openingHour: number; // UTC hour
  closingHour: number; // UTC hour
  tradingVolume: number; // 0-10 scale
  liquidityRating: number; // 0-10 scale
}

/**
 * Market transition
 */
export interface MarketTransition {
  fromRegion: MarketRegion;
  toRegion: MarketRegion;
  startHour: number; // UTC hour
  endHour: number; // UTC hour
  volatilityRating: number; // 0-10 scale
  opportunityFrequency: number; // 0-10 scale
}

/**
 * Time zone arbitrage opportunity
 */
export interface TimeZoneArbitrageOpportunity extends TimeZoneArbitrage {
  buyExchange: string;
  sellExchange: string;
  buyRegion: MarketRegion;
  sellRegion: MarketRegion;
  transitionType: 'opening' | 'closing' | 'overlap';
  volatilityScore: number;
  liquidityScore: number;
  status: 'active' | 'executed' | 'completed' | 'expired' | 'failed';
  notes: string[];
}/**

 * Time zone arbitrage trade
 */
export interface TimeZoneArbitrageTrade {
  id: string;
  opportunityId: string;
  asset: string;
  buyExchange: string;
  sellExchange: string;
  buyRegion: MarketRegion;
  sellRegion: MarketRegion;
  quantity: number;
  buyPrice: number;
  sellPrice: number;
  priceDifference: number;
  priceDifferencePercentage: number;
  executionWindow: number; // milliseconds
  buyExecuted: boolean;
  sellExecuted: boolean;
  buyExecutionTime: Date | null;
  sellExecutionTime: Date | null;
  pnl: number | null;
  pnlPercentage: number | null;
  status: 'pending' | 'partial' | 'active' | 'completed' | 'failed';
  startTime: Date | null;
  completionTime: Date | null;
  notes: string[];
}

/**
 * Time zone arbitrage configuration
 */
export interface TimeZoneArbitrageConfig {
  minPriceDifferencePercentage: number;
  minConfidence: number;
  maxPositionSizeUsd: number;
  maxActiveTrades: number;
  scanIntervalMs: number;
  executionWindowMs: number;
  monitoredAssets: string[];
  asiaExchanges: string[];
  europeExchanges: string[];
  americasExchanges: string[];
  volatilityThreshold: number;
  liquidityThreshold: number;
}

/**
 * Time Zone Arbitrage Exploitation System
 * 
 * REVOLUTIONARY INSIGHT: Cryptocurrency markets operate 24/7, but trading activity
 * and liquidity shift between Asia, Europe, and Americas as each region's trading
 * day begins and ends. During these transition periods (especially Asia→Europe and
 * Europe→Americas), significant price gaps often emerge for the same assets across
 * exchanges in different regions. By systematically monitoring these transition
 * windows and executing rapid arbitrage trades, we can capture consistent profits
 * from these temporary inefficiencies.
 */
export class TimeZoneArbitrageExploitation extends EventEmitter {
  private exchangeManager: ExchangeManager;
  private config: TimeZoneArbitrageConfig;
  private exchangeRegions: Map<string, ExchangeWithRegion> = new Map();
  private marketTransitions: MarketTransition[] = [];
  private opportunities: Map<string, TimeZoneArbitrageOpportunity> = new Map();
  private activeTrades: Map<string, TimeZoneArbitrageTrade> = new Map();
  private completedTrades: TimeZoneArbitrageTrade[] = [];
  private lastPrices: Map<string, Map<string, number>> = new Map(); // exchange -> symbol -> price
  private isRunning: boolean = false;
  private scanInterval: NodeJS.Timeout | null = null;
  private accountBalance: number = 1000;
  private accountId: string = 'default'; 
 /**
   * Constructor
   * @param exchangeManager Exchange manager
   * @param config Configuration
   */
  constructor(
    exchangeManager: ExchangeManager,
    config?: Partial<TimeZoneArbitrageConfig>
  ) {
    super();
    this.exchangeManager = exchangeManager;
    
    // Default configuration
    this.config = {
      minPriceDifferencePercentage: 0.3, // 0.3% minimum price difference
      minConfidence: 0.7, // 70% minimum confidence
      maxPositionSizeUsd: 10000, // $10,000 maximum position size
      maxActiveTrades: 10,
      scanIntervalMs: 30 * 1000, // 30 seconds
      executionWindowMs: 30 * 60 * 1000, // 30 minutes
      monitoredAssets: ['BTC', 'ETH', 'SOL', 'BNB', 'XRP'],
      asiaExchanges: ['binance', 'okx', 'huobi', 'bitfinex'],
      europeExchanges: ['kraken', 'bitstamp', 'bitfinex'],
      americasExchanges: ['coinbase', 'gemini', 'kraken'],
      volatilityThreshold: 6, // 0-10 scale
      liquidityThreshold: 5 // 0-10 scale
    };
    
    // Override with provided config
    if (config) {
      this.config = { ...this.config, ...config };
    }
    
    // Initialize exchange regions
    this.initializeExchangeRegions();
    
    // Initialize market transitions
    this.initializeMarketTransitions();
  }
  
  /**
   * Initialize exchange regions
   */
  private initializeExchangeRegions(): void {
    // Asia exchanges
    for (const exchange of this.config.asiaExchanges) {
      this.exchangeRegions.set(exchange, {
        exchange,
        region: MarketRegion.ASIA,
        openingHour: 1, // 1:00 UTC (9:00 JST)
        closingHour: 8, // 8:00 UTC (16:00 JST)
        tradingVolume: 7 + Math.random() * 3, // 7-10 scale
        liquidityRating: 6 + Math.random() * 4 // 6-10 scale
      });
    }
    
    // Europe exchanges
    for (const exchange of this.config.europeExchanges) {
      this.exchangeRegions.set(exchange, {
        exchange,
        region: MarketRegion.EUROPE,
        openingHour: 7, // 7:00 UTC (8:00 CET)
        closingHour: 16, // 16:00 UTC (17:00 CET)
        tradingVolume: 6 + Math.random() * 3, // 6-9 scale
        liquidityRating: 6 + Math.random() * 3 // 6-9 scale
      });
    }
    
    // Americas exchanges
    for (const exchange of this.config.americasExchanges) {
      this.exchangeRegions.set(exchange, {
        exchange,
        region: MarketRegion.AMERICAS,
        openingHour: 13, // 13:00 UTC (9:00 EST)
        closingHour: 21, // 21:00 UTC (17:00 EST)
        tradingVolume: 7 + Math.random() * 3, // 7-10 scale
        liquidityRating: 7 + Math.random() * 3 // 7-10 scale
      });
    }
  }
  
  /**
   * Initialize market transitions
   */
  private initializeMarketTransitions(): void {
    // Asia to Europe transition
    this.marketTransitions.push({
      fromRegion: MarketRegion.ASIA,
      toRegion: MarketRegion.EUROPE,
      startHour: 6, // 6:00 UTC
      endHour: 9, // 9:00 UTC
      volatilityRating: 8, // High volatility
      opportunityFrequency: 9 // High opportunity frequency
    });
    
    // Europe to Americas transition
    this.marketTransitions.push({
      fromRegion: MarketRegion.EUROPE,
      toRegion: MarketRegion.AMERICAS,
      startHour: 12, // 12:00 UTC
      endHour: 15, // 15:00 UTC
      volatilityRating: 9, // Very high volatility
      opportunityFrequency: 8 // High opportunity frequency
    });
    
    // Americas to Asia transition
    this.marketTransitions.push({
      fromRegion: MarketRegion.AMERICAS,
      toRegion: MarketRegion.ASIA,
      startHour: 22, // 22:00 UTC
      endHour: 2, // 2:00 UTC (next day)
      volatilityRating: 7, // High volatility
      opportunityFrequency: 7 // High opportunity frequency
    });
  }  
/**
   * Start the time zone arbitrage exploitation system
   * @param accountId Account ID
   * @param accountBalance Account balance
   */
  async start(
    accountId: string = 'default',
    accountBalance: number = 1000
  ): Promise<void> {
    if (this.isRunning) {
      console.log('🕒 Time zone arbitrage exploitation system already running');
      return;
    }
    
    console.log('🚀 STARTING TIME ZONE ARBITRAGE EXPLOITATION SYSTEM...');
    
    // Set account details
    this.accountId = accountId;
    this.accountBalance = accountBalance;
    
    // Start price monitoring
    this.startPriceMonitoring();
    
    // Start opportunity scanning
    this.startOpportunityScan();
    
    this.isRunning = true;
    console.log(`🕒 TIME ZONE ARBITRAGE EXPLOITATION SYSTEM ACTIVE! Monitoring ${this.config.monitoredAssets.length} assets across ${this.exchangeRegions.size} exchanges in ${Object.keys(MarketRegion).length} regions`);
  }
  
  /**
   * Start price monitoring
   */
  private startPriceMonitoring(): void {
    console.log('📡 STARTING PRICE MONITORING...');
    
    // Initialize last prices map
    for (const exchange of this.exchangeRegions.keys()) {
      this.lastPrices.set(exchange, new Map());
    }
    
    // Listen for price updates from exchange manager
    this.exchangeManager.on('priceUpdate', (priceUpdate) => {
      const { exchange, symbol, price } = priceUpdate;
      
      // Store price
      const exchangePrices = this.lastPrices.get(exchange) || new Map();
      exchangePrices.set(symbol, price);
      this.lastPrices.set(exchange, exchangePrices);
    });
  }
  
  /**
   * Start opportunity scan
   */
  private startOpportunityScan(): void {
    console.log('🔍 STARTING OPPORTUNITY SCAN...');
    
    // Scan for opportunities immediately
    this.scanForOpportunities();
    
    // Set up interval for regular opportunity scanning
    this.scanInterval = setInterval(() => {
      this.scanForOpportunities();
    }, this.config.scanIntervalMs);
  }
  
  /**
   * Scan for opportunities
   */
  private scanForOpportunities(): void {
    // Check if we're in a market transition period
    const currentTransition = this.getCurrentMarketTransition();
    
    if (!currentTransition) {
      // Not in a transition period, scan less frequently
      return;
    }
    
    console.log(`🔍 SCANNING FOR TIME ZONE ARBITRAGE OPPORTUNITIES DURING ${currentTransition.fromRegion.toUpperCase()} → ${currentTransition.toRegion.toUpperCase()} TRANSITION...`);
    
    // Get exchanges for each region in the transition
    const fromExchanges = this.getExchangesForRegion(currentTransition.fromRegion);
    const toExchanges = this.getExchangesForRegion(currentTransition.toRegion);
    
    // Scan for opportunities for each monitored asset
    for (const asset of this.config.monitoredAssets) {
      this.scanAssetForOpportunities(asset, fromExchanges, toExchanges, currentTransition);
    }
  }  
/**
   * Get current market transition
   * @returns Current market transition or null if not in a transition period
   */
  private getCurrentMarketTransition(): MarketTransition | null {
    const now = new Date();
    const currentHour = now.getUTCHours();
    
    // Check if we're in a transition period
    for (const transition of this.marketTransitions) {
      if (transition.startHour <= transition.endHour) {
        // Normal case (e.g., 6-9)
        if (currentHour >= transition.startHour && currentHour <= transition.endHour) {
          return transition;
        }
      } else {
        // Overnight case (e.g., 22-2)
        if (currentHour >= transition.startHour || currentHour <= transition.endHour) {
          return transition;
        }
      }
    }
    
    return null;
  }
  
  /**
   * Get exchanges for region
   * @param region Market region
   * @returns Exchanges for region
   */
  private getExchangesForRegion(region: MarketRegion): string[] {
    const exchanges: string[] = [];
    
    for (const [exchange, data] of this.exchangeRegions.entries()) {
      if (data.region === region) {
        exchanges.push(exchange);
      }
    }
    
    return exchanges;
  }
  
  /**
   * Scan asset for opportunities
   * @param asset Asset
   * @param fromExchanges From exchanges
   * @param toExchanges To exchanges
   * @param transition Market transition
   */
  private scanAssetForOpportunities(
    asset: string,
    fromExchanges: string[],
    toExchanges: string[],
    transition: MarketTransition
  ): void {
    const symbol = `${asset}/USDT`;
    
    // Get prices from all exchanges
    const prices: { exchange: string, price: number }[] = [];
    
    // Collect prices from 'from' exchanges
    for (const exchange of fromExchanges) {
      const exchangePrices = this.lastPrices.get(exchange);
      if (exchangePrices && exchangePrices.has(symbol)) {
        prices.push({
          exchange,
          price: exchangePrices.get(symbol)!
        });
      }
    }
    
    // Collect prices from 'to' exchanges
    for (const exchange of toExchanges) {
      const exchangePrices = this.lastPrices.get(exchange);
      if (exchangePrices && exchangePrices.has(symbol)) {
        prices.push({
          exchange,
          price: exchangePrices.get(symbol)!
        });
      }
    }
    
    // Need at least one price from each region
    const fromRegionPrices = prices.filter(p => fromExchanges.includes(p.exchange));
    const toRegionPrices = prices.filter(p => toExchanges.includes(p.exchange));
    
    if (fromRegionPrices.length === 0 || toRegionPrices.length === 0) {
      return;
    }
    
    // Find min and max prices
    const minPrice = prices.reduce((min, p) => p.price < min.price ? p : min, prices[0]);
    const maxPrice = prices.reduce((max, p) => p.price > max.price ? p : max, prices[0]);
    
    // Calculate price difference
    const priceDifference = maxPrice.price - minPrice.price;
    const priceDifferencePercentage = (priceDifference / minPrice.price) * 100;
    
    // Skip if price difference is too small
    if (priceDifferencePercentage < this.config.minPriceDifferencePercentage) {
      return;
    }
    
    // Get exchange regions
    const buyExchangeRegion = this.exchangeRegions.get(minPrice.exchange);
    const sellExchangeRegion = this.exchangeRegions.get(maxPrice.exchange);
    
    if (!buyExchangeRegion || !sellExchangeRegion) {
      return;
    }
    
    // Calculate volatility and liquidity scores
    const volatilityScore = transition.volatilityRating;
    const liquidityScore = (buyExchangeRegion.liquidityRating + sellExchangeRegion.liquidityRating) / 2;
    
    // Skip if volatility or liquidity is too low
    if (volatilityScore < this.config.volatilityThreshold || liquidityScore < this.config.liquidityThreshold) {
      return;
    }   
 // Determine transition type
    let transitionType: 'opening' | 'closing' | 'overlap';
    
    const currentHour = new Date().getUTCHours();
    
    if (currentHour < buyExchangeRegion.closingHour && currentHour >= sellExchangeRegion.openingHour) {
      transitionType = 'overlap';
    } else if (currentHour >= buyExchangeRegion.closingHour) {
      transitionType = 'closing';
    } else {
      transitionType = 'opening';
    }
    
    // Calculate confidence based on multiple factors
    let confidence = 0.7; // Base confidence
    
    // Adjust confidence based on price difference
    confidence += Math.min(0.1, priceDifferencePercentage / 10); // Up to +0.1 for large price differences
    
    // Adjust confidence based on volatility
    confidence += Math.min(0.1, volatilityScore / 100); // Up to +0.1 for high volatility
    
    // Adjust confidence based on liquidity
    confidence += Math.min(0.1, liquidityScore / 100); // Up to +0.1 for high liquidity
    
    // Cap confidence at 0.95
    confidence = Math.min(0.95, confidence);
    
    // Skip if confidence is too low
    if (confidence < this.config.minConfidence) {
      return;
    }
    
    // Check if we already have an active opportunity for this asset pair
    const existingOpportunity = Array.from(this.opportunities.values())
      .find(o => o.asset === asset && 
                o.buyExchange === minPrice.exchange && 
                o.sellExchange === maxPrice.exchange && 
                o.status === 'active');
    
    if (existingOpportunity) {
      // Update existing opportunity
      existingOpportunity.priceGap = priceDifference;
      existingOpportunity.confidence = confidence;
      existingOpportunity.optimalExecutionAt = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes from now
      
      // Store updated opportunity
      this.opportunities.set(existingOpportunity.id, existingOpportunity);
      return;
    }
    
    // Create new opportunity
    const opportunity: TimeZoneArbitrageOpportunity = {
      id: uuidv4(),
      asset,
      closingMarket: buyExchangeRegion.region,
      openingMarket: sellExchangeRegion.region,
      priceGap: priceDifference,
      volume: Math.min(buyExchangeRegion.tradingVolume, sellExchangeRegion.tradingVolume),
      executionWindow: this.config.executionWindowMs,
      confidence,
      detectedAt: new Date(),
      optimalExecutionAt: new Date(Date.now() + 5 * 60 * 1000), // 5 minutes from now
      buyExchange: minPrice.exchange,
      sellExchange: maxPrice.exchange,
      buyRegion: buyExchangeRegion.region,
      sellRegion: sellExchangeRegion.region,
      transitionType,
      volatilityScore,
      liquidityScore,
      status: 'active',
      notes: [
        `Detected ${priceDifferencePercentage.toFixed(2)}% price difference for ${asset} during ${transition.fromRegion} → ${transition.toRegion} transition`,
        `Buy on ${minPrice.exchange} @ ${minPrice.price.toFixed(2)}, Sell on ${maxPrice.exchange} @ ${maxPrice.price.toFixed(2)}`,
        `Transition type: ${transitionType}, Volatility: ${volatilityScore}/10, Liquidity: ${liquidityScore.toFixed(1)}/10`,
        `Confidence: ${(confidence * 100).toFixed(2)}%`
      ]
    };
    
    // Store opportunity
    this.opportunities.set(opportunity.id, opportunity);
    
    console.log(`🕒 TIME ZONE ARBITRAGE OPPORTUNITY DETECTED: ${asset}`);
    console.log(`📊 ${priceDifferencePercentage.toFixed(2)}% price difference during ${transition.fromRegion} → ${transition.toRegion} transition`);
    console.log(`📊 Buy on ${minPrice.exchange} @ ${minPrice.price.toFixed(2)}, Sell on ${maxPrice.exchange} @ ${maxPrice.price.toFixed(2)}`);
    
    // Emit opportunity detected event
    this.emit('opportunityDetected', opportunity);
    
    // Create trade if confidence is high enough
    if (confidence >= this.config.minConfidence) {
      this.createTimeZoneArbitrageTrade(opportunity);
    }
  }  /**
  
 * Create time zone arbitrage trade
   * @param opportunity Time zone arbitrage opportunity
   */
  private createTimeZoneArbitrageTrade(opportunity: TimeZoneArbitrageOpportunity): void {
    // Check if we already have too many active trades
    if (this.activeTrades.size >= this.config.maxActiveTrades) {
      console.log(`⚠️ Maximum active trades (${this.config.maxActiveTrades}) reached, skipping trade`);
      return;
    }
    
    console.log(`🕒 CREATING TIME ZONE ARBITRAGE TRADE: ${opportunity.asset}`);
    
    // Get prices
    const buyExchangePrices = this.lastPrices.get(opportunity.buyExchange);
    const sellExchangePrices = this.lastPrices.get(opportunity.sellExchange);
    
    if (!buyExchangePrices || !sellExchangePrices) {
      console.log(`⚠️ Missing price data for ${opportunity.buyExchange} or ${opportunity.sellExchange}`);
      return;
    }
    
    const symbol = `${opportunity.asset}/USDT`;
    const buyPrice = buyExchangePrices.get(symbol);
    const sellPrice = sellExchangePrices.get(symbol);
    
    if (!buyPrice || !sellPrice) {
      console.log(`⚠️ Missing price data for ${symbol} on ${opportunity.buyExchange} or ${opportunity.sellExchange}`);
      return;
    }
    
    // Calculate price difference
    const priceDifference = sellPrice - buyPrice;
    const priceDifferencePercentage = (priceDifference / buyPrice) * 100;
    
    // Skip if price difference is now too small
    if (priceDifferencePercentage < this.config.minPriceDifferencePercentage) {
      console.log(`⚠️ Price difference has decreased to ${priceDifferencePercentage.toFixed(2)}%, below threshold`);
      return;
    }
    
    // Calculate position size based on available capital
    const positionSize = this.calculatePositionSize(opportunity, buyPrice);
    
    // Create trade
    const trade: TimeZoneArbitrageTrade = {
      id: uuidv4(),
      opportunityId: opportunity.id,
      asset: opportunity.asset,
      buyExchange: opportunity.buyExchange,
      sellExchange: opportunity.sellExchange,
      buyRegion: opportunity.buyRegion,
      sellRegion: opportunity.sellRegion,
      quantity: positionSize,
      buyPrice,
      sellPrice,
      priceDifference,
      priceDifferencePercentage,
      executionWindow: opportunity.executionWindow,
      buyExecuted: false,
      sellExecuted: false,
      buyExecutionTime: null,
      sellExecutionTime: null,
      pnl: null,
      pnlPercentage: null,
      status: 'pending',
      startTime: null,
      completionTime: null,
      notes: [
        `Created time zone arbitrage trade for ${opportunity.asset}`,
        `Buy on ${opportunity.buyExchange} @ ${buyPrice.toFixed(2)}, Sell on ${opportunity.sellExchange} @ ${sellPrice.toFixed(2)}`,
        `Price difference: ${priceDifference.toFixed(2)} (${priceDifferencePercentage.toFixed(2)}%)`,
        `Quantity: ${positionSize}`
      ]
    };
    
    // Store trade
    this.activeTrades.set(trade.id, trade);
    
    // Update opportunity status
    opportunity.status = 'executed';
    this.opportunities.set(opportunity.id, opportunity);
    
    console.log(`📊 TRADE CREATED: Buy on ${opportunity.buyExchange}, Sell on ${opportunity.sellExchange}`);
    console.log(`📊 Quantity: ${positionSize}, Expected profit: ${(priceDifferencePercentage * positionSize * buyPrice / 100).toFixed(2)} (${priceDifferencePercentage.toFixed(2)}%)`);
    
    // Emit trade created event
    this.emit('tradeCreated', trade);
    
    // Execute trade
    this.executeTrade(trade);
  }  /
**
   * Calculate position size
   * @param opportunity Time zone arbitrage opportunity
   * @param price Price
   * @returns Position size
   */
  private calculatePositionSize(opportunity: TimeZoneArbitrageOpportunity, price: number): number {
    // Calculate maximum position size based on available capital and max position size
    const maxCapital = Math.min(this.accountBalance * 0.2, this.config.maxPositionSizeUsd);
    
    // Calculate position size based on price
    const maxSize = maxCapital / price;
    
    // Adjust position size based on confidence
    const confidenceMultiplier = 0.5 + (opportunity.confidence * 0.5); // 0.5-1.0 based on confidence
    
    // Adjust position size based on volatility
    const volatilityMultiplier = 0.5 + (opportunity.volatilityScore / 20); // 0.5-1.0 based on volatility
    
    // Adjust position size based on liquidity
    const liquidityMultiplier = 0.5 + (opportunity.liquidityScore / 20); // 0.5-1.0 based on liquidity
    
    // Calculate final position size
    const positionSize = maxSize * confidenceMultiplier * volatilityMultiplier * liquidityMultiplier;
    
    // Round to 4 decimal places
    return Math.floor(positionSize * 10000) / 10000;
  }
  
  /**
   * Execute trade
   * @param trade Time zone arbitrage trade
   */
  private async executeTrade(trade: TimeZoneArbitrageTrade): Promise<void> {
    console.log(`⚡ EXECUTING TIME ZONE ARBITRAGE TRADE: ${trade.asset}...`);
    
    try {
      // In a real implementation, this would execute the trades on the exchanges
      // For now, we'll simulate execution
      
      // Execute buy order
      trade.buyExecuted = true;
      trade.buyExecutionTime = new Date();
      
      // Add note
      trade.notes.push(`Executed buy order on ${trade.buyExchange} at ${trade.buyExecutionTime.toISOString()}`);
      
      // Execute sell order
      trade.sellExecuted = true;
      trade.sellExecutionTime = new Date();
      
      // Add note
      trade.notes.push(`Executed sell order on ${trade.sellExchange} at ${trade.sellExecutionTime.toISOString()}`);
      
      // Update trade status
      trade.status = 'active';
      trade.startTime = new Date();
      
      // Calculate P&L
      const pnl = (trade.sellPrice - trade.buyPrice) * trade.quantity;
      const pnlPercentage = ((trade.sellPrice - trade.buyPrice) / trade.buyPrice) * 100;
      
      trade.pnl = pnl;
      trade.pnlPercentage = pnlPercentage;
      
      // Add note
      trade.notes.push(`Trade executed with P&L: ${pnl.toFixed(2)} (${pnlPercentage.toFixed(2)}%)`);
      
      console.log(`✅ TRADE EXECUTED: Buy on ${trade.buyExchange}, Sell on ${trade.sellExchange}`);
      console.log(`💰 P&L: ${pnl.toFixed(2)} (${pnlPercentage.toFixed(2)}%)`);
      
      // Emit trade executed event
      this.emit('tradeExecuted', trade);
      
      // Complete trade
      this.completeTrade(trade);
      
    } catch (error) {
      console.error(`❌ ERROR EXECUTING TRADE: ${error}`);
      
      // Update trade status
      trade.status = 'failed';
      trade.notes.push(`Trade failed: ${error}`);
      
      // Emit trade failed event
      this.emit('tradeFailed', trade, error);
    }
  }  /*
*
   * Complete trade
   * @param trade Time zone arbitrage trade
   */
  private completeTrade(trade: TimeZoneArbitrageTrade): void {
    // Update trade
    trade.status = 'completed';
    trade.completionTime = new Date();
    
    // Add note
    trade.notes.push(`Trade completed at ${trade.completionTime.toISOString()}`);
    
    console.log(`✅ TRADE COMPLETED: ${trade.asset}`);
    console.log(`💰 P&L: ${trade.pnl?.toFixed(2)} (${trade.pnlPercentage?.toFixed(2)}%)`);
    
    // Move to completed trades
    this.completedTrades.push(trade);
    this.activeTrades.delete(trade.id);
    
    // Emit trade completed event
    this.emit('tradeCompleted', trade);
  }
  
  /**
   * Get opportunities
   * @returns Time zone arbitrage opportunities
   */
  getOpportunities(): TimeZoneArbitrageOpportunity[] {
    return Array.from(this.opportunities.values());
  }
  
  /**
   * Get active trades
   * @returns Active trades
   */
  getActiveTrades(): TimeZoneArbitrageTrade[] {
    return Array.from(this.activeTrades.values());
  }
  
  /**
   * Get completed trades
   * @returns Completed trades
   */
  getCompletedTrades(): TimeZoneArbitrageTrade[] {
    return this.completedTrades;
  }
  
  /**
   * Get statistics
   * @returns Statistics
   */
  getStatistics(): any {
    // Calculate success rate
    const successfulTrades = this.completedTrades.filter(t => t.pnl !== null && t.pnl > 0);
    const successRate = this.completedTrades.length > 0
      ? successfulTrades.length / this.completedTrades.length
      : 0;
    
    // Calculate average profit
    const totalPnl = this.completedTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
    const avgPnl = this.completedTrades.length > 0
      ? totalPnl / this.completedTrades.length
      : 0;
    
    // Calculate average profit percentage
    const totalPnlPercentage = this.completedTrades.reduce((sum, t) => sum + (t.pnlPercentage || 0), 0);
    const avgPnlPercentage = this.completedTrades.length > 0
      ? totalPnlPercentage / this.completedTrades.length
      : 0;
    
    // Calculate transition statistics
    const transitionStats = new Map<string, { trades: number, successRate: number, avgPnl: number }>();
    
    for (const transition of ['asia_europe', 'europe_americas', 'americas_asia']) {
      let transitionTrades: TimeZoneArbitrageTrade[] = [];
      
      if (transition === 'asia_europe') {
        transitionTrades = this.completedTrades.filter(
          t => t.buyRegion === MarketRegion.ASIA && t.sellRegion === MarketRegion.EUROPE
        );
      } else if (transition === 'europe_americas') {
        transitionTrades = this.completedTrades.filter(
          t => t.buyRegion === MarketRegion.EUROPE && t.sellRegion === MarketRegion.AMERICAS
        );
      } else if (transition === 'americas_asia') {
        transitionTrades = this.completedTrades.filter(
          t => t.buyRegion === MarketRegion.AMERICAS && t.sellRegion === MarketRegion.ASIA
        );
      }
      
      const transitionSuccessfulTrades = transitionTrades.filter(t => t.pnl !== null && t.pnl > 0);
      const transitionTotalPnl = transitionTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
      
      transitionStats.set(transition, {
        trades: transitionTrades.length,
        successRate: transitionTrades.length > 0 ? transitionSuccessfulTrades.length / transitionTrades.length : 0,
        avgPnl: transitionTrades.length > 0 ? transitionTotalPnl / transitionTrades.length : 0
      });
    } 
   // Calculate asset statistics
    const assetStats = new Map<string, { trades: number, successRate: number, avgPnl: number }>();
    
    for (const asset of this.config.monitoredAssets) {
      const assetTrades = this.completedTrades.filter(t => t.asset === asset);
      const assetSuccessfulTrades = assetTrades.filter(t => t.pnl !== null && t.pnl > 0);
      const assetTotalPnl = assetTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
      
      assetStats.set(asset, {
        trades: assetTrades.length,
        successRate: assetTrades.length > 0 ? assetSuccessfulTrades.length / assetTrades.length : 0,
        avgPnl: assetTrades.length > 0 ? assetTotalPnl / assetTrades.length : 0
      });
    }
    
    return {
      opportunities: this.opportunities.size,
      activeTrades: this.activeTrades.size,
      completedTrades: this.completedTrades.length,
      successfulTrades: successfulTrades.length,
      failedTrades: this.completedTrades.length - successfulTrades.length,
      successRate: successRate * 100,
      totalPnl,
      avgPnl,
      avgPnlPercentage,
      transitionStats: Object.fromEntries(transitionStats),
      assetStats: Object.fromEntries(assetStats),
      isRunning: this.isRunning,
      config: this.config
    };
  }
  
  /**
   * Update configuration
   * @param config New configuration
   */
  updateConfig(config: Partial<TimeZoneArbitrageConfig>): void {
    this.config = { ...this.config, ...config };
    console.log('⚙️ Updated time zone arbitrage configuration');
  }
  
  /**
   * Stop the time zone arbitrage exploitation system
   */
  stop(): void {
    console.log('🛑 STOPPING TIME ZONE ARBITRAGE EXPLOITATION SYSTEM...');
    
    // Clear scan interval
    if (this.scanInterval) {
      clearInterval(this.scanInterval);
      this.scanInterval = null;
    }
    
    this.isRunning = false;
    console.log('🛑 TIME ZONE ARBITRAGE EXPLOITATION SYSTEM STOPPED');
  }
}

export default TimeZoneArbitrageExploitation;